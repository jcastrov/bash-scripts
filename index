#!/usr/bin/env bash

# Scripts path depends on the current shell.
bash_scripts_path=$(dirname "${BASH_SOURCE[0]}");
if [[ -n $ZSH_VERSION ]]; then bash_scripts_path=${0:A:h}; fi

echo_regex_substring() {
  local substring=$(echo "$1" | grep -oE "$2");
  [ -z $substring ] && { return 1; }
  echo "$substring";
}

source "$bash_scripts_path/print"
source "$bash_scripts_path/git_utils"
source "$bash_scripts_path/git"
source "$bash_scripts_path/github"
source "$bash_scripts_path/windows"

br() {
  print_info "Applying new changes";
  run_cmd ". $bash_scripts_path/index";
}

# Checks if a command is avaiable in your current session. Returns 0 if
# the command exists. Otherwise, shows an error message and returns 1 if 
# the command doesn't exist.
#     $1: Command.
cmd_exists() {
  if ! command -v $1 &> /dev/null; then 
    print_error "`color_cyan $1` command doesn't exist.";
    return 1;
  fi
}

# Enables Brew on the current terminal session.
ebrew() {
  cmd_exists brew > /dev/null 2>&1 && return 1;
  print_info "Enabling `color_cyan brew`...";
  run_cmd "$(/opt/homebrew/bin/brew shellenv)";
  run_cmd "brew --version";
}

# Enables NVM on the current terminal session.
envm() {
  cmd_exists nvm > /dev/null 2>&1 && return 1;
  ebrew;
  print_info "Enabling `color_cyan nvm`...";
  run_cmd "export NVM_DIR=~/.nvm";
  run_cmd "source $(brew --prefix nvm)/nvm.sh";
  run_cmd "node --version";
}

epython() {
  cmd_exists python > /dev/null 2>&1 && return 1;
  ebrew;
  print_info "Enabling `color_cyan python`...";
  export PYENV_ROOT="$HOME/.pyenv"
  command -v pyenv >/dev/null || export PATH="$PYENV_ROOT/bin:$PATH"
  eval "$(pyenv init -)"
  pyenv global 2;
  run_cmd "which python";
  run_cmd "python --version";
}

echo_jira_ticket_url() {
  echo "https://$BP_JIRA_ORGANIZATION.atlassian.net/browse/$1";
}

# Checks if a function has parameters. Returns 0 if there are paramters. 
# Otherwise returns 1.
#     $@: Parameters
has_parameters() {
  if [ $# -eq 0 ]; then
    print_error "Missing parameters."; 
    return 1;
  fi
  return 0;
}

jira() {
  local branch=$1;
  [ -z "$1" ] && { 
    ! is_git_directory && return 1;
    branch=$(echo_current_branch);
  }
  local ticket_name=$(echo_regex_substring $branch "^[[:alpha:]]+-[[:digit:]]+");
  if [[ -z $ticket_name ]]; then
    print_error "Branch `color_yellow $branch` is not a valid ticket name.";
    return 1;
  fi
  run_cmd "open $(echo_jira_ticket_url $ticket_name)";
}

# Prints and runs a command ($1).
# (Optional) Assigns the output to a variable name without "$" ($2)
run_cmd() {
  print_cmd "$1";
  if [[ $# == 1 ]]; then
    # "eval" runs commands with pipes: https://stackoverflow.com/a/48098280/1054579
    eval $1;
  else
    eval "$2=\"$(eval $1)\""
  fi

  return $?;
}

# Opens VSCode for the current directory. If $1 is specified, VSCode opens for
# the root of the git repository, or that path.
vsc() {
  local vsc_path="${1:-.}";
  local type="directory";
  is_git_directory "$vsc_path" > /dev/null 2>&1 && {
    vsc_path=$(cd $vsc_path; echo `git rev-parse --show-toplevel`;) 
    type=`color_magenta "repository"`;
  }
  local directory="$(basename "`cd "$vsc_path"; pwd`")";
  print_info "Opening `color_cyan "$directory"` $type on VSCode.";
  run_cmd "code \"$vsc_path\"";
}
