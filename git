#!/usr/bin/env bash

source "$(dirname "${BASH_SOURCE[0]}")/git_utils"

# Adds files and shows a quick status
gita() {
  has_parameters $@ || return 1;
  run_cmd "git add $1";
  run_cmd "git status -s"
}

# Deletes a branch locally
gitbD() {
  branch_locally_exists $1 || return 1;
  question "Are you sure to force delete `__c $1 1` locally?"
  [ $? != 0 ] && return 0;
  run_cmd "$git_switch `git symbolic-ref refs/remotes/origin/HEAD | sed 's@^refs/remotes/origin/@@'`";
  run_cmd "git branch -D $1";
}

# Gets the list of branches created in remote
#    $@: Additional parameters
gitbl() {
  run_cmd "git for-each-ref --sort=authorname --format='%(committerdate) %09 %(authorname) %09 %(refname)' refs/remotes $@"
}

# Renames a branch
#    $@: Branch name and additional parameters
gitbm() { run_cmd "git branch -m $@"; }

# Commits your changes
#    $1: Summary.
#    $2 (optional): Description.
gitc() {
  has_parameters $@ || return 1;
  local current_branch=$(echo_current_branch);
  print_info "Committing your changes.";
  run_cmd "git commit -m \"$current_branch: $1\" $2";
}
gitca() { gitc "$1" "--amend"; }

gitchk() { run_cmd "git checkout $@"; }

# Cherry pick commands
gitchp() { run_cmd "git cherry-pick $1"; }
gitchpa() { run_cmd "git cherry-pick --abort"; }
gitchpc() { run_cmd "git cherry-pick --continue"; }

# Fetches branches
gitf() { 
  print_info "Downloading objects and refs from origin..."
  run_cmd "git fetch -p";
}

# Merge commands
gitm() { run_cmd "git merge $1"; }
gitma() { run_cmd "git merge --abort"; }
gitmc() { run_cmd "git merge --continue"; }
gitmo() { run_cmd "git merge $2 origin/$1 --no-edit"; }

# Opens remote on the browser with the current branch or a specific one ($1),
# optionally opening a specific file ($2).
#     $1 (optional): Branch name
#     $2 (optional): Relative path of the file
gito() {
  is_git_directory && local branch=$1 || return 1;
  [ -z "$1" ] && get_current_branch && branch=$__cmd_value;
  [ -n "$2" ] && { gitof $2 $1; return 0; }
  run_cmd "open `get_repo_url`/tree/$branch";
}

# Opens a specific file on remote for the current branch. If $2 is specified,
# $2 will be the selected branch.
#     $1: Relative path of the file
#     $2 (Optional): Branch name 
gitof() {
  is_git_directory && has_parameters $@ && local branch=$2 || return 1;
  [ -z "$2" ] && get_current_branch && branch=$__cmd_value;
  run_cmd "open `get_repo_url`/blob/$branch/$1";
}

# Pull commands
gitpl() { run_cmd "git pull"; }
gitplr() { run_cmd "git pull -r"; }

# Compares the source branch (Current branch) with the destination branch ($1)
# on the repo URL. If $2 is specified, $2 will be the source branch instead.
#     $1: Destination branch
#     $2 (Optional): Source branch
gitprc() { 
  is_git_directory && has_parameters $@ || return 1;

  local source_branch=$1;
  local destination_branch=$2;
  [ $# == 1 ] && {
    source_branch=$(echo_current_branch);
    destination_branch=$1;
  }

  if [[ $destination_branch == "Release" ]]; then
    # git branch -r: Get remote branches.
    # grep -E '^ *origin/Release-20*': Filter branches that starts with " origin/Release-20*".
    # sed -e 's/^ *origin\///': Removes " origin/".
    # sort -rV: Sort lines. V is alphabetic order. -r is reverse order.
    # head -n 1: Shows the first result only
    local command="git branch -r | grep -E '^ *origin/Release-20*' | sed -e 's/^ *origin\///' | sort -rV | head -n 1";
    run_cmd "$command" "destination_branch"
  fi

  run_cmd "open `get_repo_url`/compare/$destination_branch...$source_branch"
}

# Searches for pull requests on the repo URL, where the source branch is the
# current branch. If #1 is specified, $1 will be the search text.
#     $1 (Optional): Search text
gitprf() {
  is_git_directory || return 1;
  local search_text=$1;
  [ -z "$1" ] && { get_current_branch || return 1; search_text="head:$__cmd_value"; }
  run_cmd "open `get_repo_url`/pulls?q=$search_text"
}

# Pushes a branch
gitps() { 
  run_cmd "git push $@";
  [ $? != 0 ] && { return $?; }
  local current_branch=$(echo_current_branch);
  local target_branch=$current_branch;

  # If the branch ends with "-develop" or "-qa"
  if [[ $current_branch =~ -(develop|qa)$ ]]; then
    # ##*- Remove the branch name. ABC-123-qa -> qa
    gitprc "${current_branch##*-}";

    # %-* Remove the suffix. ABC-123-qa -> ABC-123
    target_branch="${current_branch%-*}";

    question "Do you want to switch back to branch $(__c $target_branch $C_CYAN)?";
    [ $? == 0 ] && { run_cmd "$git_switch $target_branch"; }
  fi
}

# Deletes a branch on remote.
#     $1: Branch name
gitpsd() {
  is_git_directory && has_parameters $@ || return 1;
  branch_on_remote_exists $1 && {
    question "Do you want to delete `__c $1 1` `__c "on remote" 3`?";
    [ $? == 0 ] && { 
      run_cmd "git push origin --delete $1";
      run_cmd "git branch --unset-upstream $1";
    }
  }
}

# Pushes a branch forcefully
gitpsf() { gitps "--force-with-lease"; }

# Pushes a branch forcefully fixing the upstream
gitpsfu() { gitpsu "--force-with-lease"; }

# Renames the current branch locally and on remote.
#     $1: New branch name
gitpsm() {
  get_current_branch && local current_branch=$__cmd_value || return 1;
  branch_on_remote_exists $__cmd_value || return 1;
  question "Are you sure to change the name from `__c $current_branch 1` to `__c $1 2`?"
  [ $? != 0 ] && return 0;
  run_cmd "git branch -m $1" &&
  run_cmd "git push origin :$current_branch $1" &&
  run_cmd "git push origin --set-upstream $1";
}

# Pushes a branch for the first time
gitpsu() { gitps "--set-upstream origin $(echo_current_branch) $@"; }

# Rebase commands
gitrb() { run_cmd "git rebase $@"; }
gitrbm() { gitrb origin/master; }
gitrba() { gitrb --abort; }
gitrbc() { gitrb --continue; }
gitrbi() { gitrb -i $@; }
gitrbih() { gitrbi HEAD~$1; }
gitrbio() { gitrbi origin/$1; }
gitrbq() { gitrb --quit; }
gitrbs() { gitrb --skip; }

# Reset commands
gitrm() { run_cmd "git reset --merge"; }
gitrs() { run_cmd "git reset $@"; }
gitrsh() { run_cmd "git reset --hard $1"; }
gitrsho() { run_cmd "git reset --hard origin/$1"; }

# Restore command
gitrt() {
  [[ $1 != "." ]] && run_cmd "$git_restore $@" && return 0;
  __option "Are you sure to restore all your modified files?"
  [ $? == 0 ] && __run "$git_restore_f";
}

# Status commands
gits() { run_cmd "git status"; }
gitss() { run_cmd "git status -s"; }

# Stash commands
gitsh() { run_cmd "git stash $@"; }
gitsha() { run_cmd "git stash apply"; }
gitshas() { run_cmd "git stash apply stash@{\"$1\"}"; }
gitshcl() { run_cmd "git stash clear"; }
gitshl() { run_cmd "git stash list"; }
gitshp() { run_cmd "git stash pop"; }
gitshps() { run_cmd "git stash save \"$1\""; }
gitshu() { run_cmd "git stash --include-untracked \"$1\""; }

# Switches or creates a branch from the current branch. Branch $1 will be
# created from $2 instead, if $2 is specified and $1 doesn't exist.
#     $1: Branch to switch or create
#     $2 (Optional): Branch or SHA starting point
gitsw() {
  has_parameters $@ || return 1;
  [ "$1" == "-" ] && {
    run_cmd "$git_switch -";
    return 0;
  }

  local start_point=$2;
  if [ -z "$2" ]; then
    start_point=$(echo_current_branch);
    branch_locally_exists $1 && { run_cmd "$git_switch $1"; return 0; }
  fi

  local on_remote=false;
  branch_on_remote_exists $1 && {
    on_remote=true;
    question "Do you want to switch to `__c $1 3` remote branch?";
    [ $? == 0 ] && {
      gitf;
      run_cmd "$git_switch $1";
      return 0;
    }
  }

  if [[ $start_point =~ ^origin/ ]]; then
    ! branch_on_remote_exists ${2#"origin/"} && return 1;
  else
    question "Do you want to create `__c $1 2` branch from local $(__c $start_point $C_RED)?";
    [ $? == 0 ] && {
      $on_remote && gitpsd $1;
      run_cmd "$git_switch_c $1 $start_point";
      return 0;
    };
    start_point="origin/$start_point";
  fi

  question "Do you want to create `__c $1 2` branch from remote $(__c $start_point $C_CYAN)?";
  [ $? == 0 ] && {
    $on_remote && gitpsd $1;
    gitf;
    run_cmd "$git_switch_c $1 $start_point";
  }
  
  return 0;
}
gitswC() { run_cmd "git switch -C $@"; }

gitsync() {
  local current_branch=$(echo_current_branch);

  # Sync should not be done from qa or develop branches.
  if [[ $current_branch == "qa" || $current_branch == "develop" || $current_branch == "dev" ]]; then
    print_error "Current branch cannot be `__c $current_branch $C_CYAN`"; return 1;
  fi

  # If branch on remote doesn't exist, stop execution. Otherwise fetch remote branches.
  ! branch_on_remote_exists $1 && return 1;
  gitf;

  # Check if the new branch exists or if it should be recreated.
  local new_branch=${current_branch}-$1;
  local switch_cmd="$git_switch_c $new_branch origin/$1";
  if branch_on_remote_exists $new_branch && branch_locally_exists $new_branch; then
    question "Do you want to update the current `__c $new_branch $C_CYAN` branch?";
    [ $? == 0 ] && { switch_cmd="$git_switch $new_branch"; }
  fi
  run_cmd $switch_cmd;

  # Only use "ours" strategy with the main branch of the repo.
  if [[ $current_branch == "main" || $current_branch == "master" ]]; then
    question "Do you want to use \"ours\" merge strategy?";
    [ $? == 0 ] && { gitmo $current_branch "-s ours"; return 0; }
  fi
  gitmo $current_branch;
}

# Checks if the current directory or a specific one is inside a Git repostory.
#     $1 (optional): Directory path to validate
is_git_directory() {
  (cd ${1:-.}; [[ $(eval "git rev-parse --is-inside-work-tree") == "true" ]] && return 0 || return 1);
  return $?;
}
